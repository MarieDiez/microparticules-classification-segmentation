# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'microparticules_Classifier_Segmenter.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtGui import QImage
from PyQt5 import QtCore, QtGui, QtWidgets
import time
import threading
from threading import Thread
from PIL import Image
from skimage.transform import hough_circle, hough_circle_peaks
from skimage.feature import blob_dog
from skimage.draw import circle_perimeter
from scipy.spatial import distance
from scipy.spatial import distance
from scipy import ndimage as ndi
from skimage.segmentation import watershed
import cv2
import os
import shutil
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

# Lock pour l'affichage 
cond = threading.Condition()

# Style de la progress bar
DEFAULT_STYLE = """
QProgressBar{
    border: 2px solid grey;
    background-color: silver;
    border-radius: 5px;
    text-align: center
}

QProgressBar::chunk {
    background-color: orange;
    width: 10px;
    margin: 1px;
}
"""
COMPLETED_STYLE = """
QProgressBar{
    border: 2px solid darkgray;
    background-color: orange;
    border-radius: 5px;
    text-align: center
}
QProgressBar::chunk {
    background-color: orange;
    width: 10px;
    margin: 1px;
}
"""

# Thread pour la gestion de l'affichage
class Action(Thread):
    def __init__(self, fonction):
        Thread.__init__(self)
        self.fonction = fonction

    def run(self):
        self.fonction()


class Ui_MainWindow(object):

    """FONCION SYSTEME"""
    def quitter(self):
            QtCore.QCoreApplication.instance().quit()

    """FONCTION DE BASE"""
    def create_dir(self):
        """
        Créations des repertoires
        """
        if os.path.isdir(("{}/Agregats".format(os.getcwd()))):
            shutil.rmtree("{}/Agregats".format(os.getcwd()))
        if os.path.isdir("{}/Simples".format(os.getcwd())):
            shutil.rmtree("{}/Simples".format(os.getcwd()))
        if os.path.isdir(("{}/MixedImages/imgJpg".format(os.getcwd()))):
            shutil.rmtree("{}/MixedImages/imgJpg".format(os.getcwd()))
        if os.path.isdir(("{}/Agregats/imgJpg".format(os.getcwd()))):
            shutil.rmtree("{}/Agregats/imgJpg".format(os.getcwd()))
        if os.path.isdir(("{}/Agregats/Segmented".format(os.getcwd()))):
            shutil.rmtree("{}/Agregats/Segmented".format(os.getcwd()))
        os.mkdir("{}/Agregats".format(os.getcwd()))
        os.mkdir("{}/Agregats/Segmented".format(os.getcwd()))
        os.mkdir("{}/Simples".format(os.getcwd()))
        if apercu:
            os.mkdir("{}/MixedImages/imgJpg".format(os.getcwd()))
            os.mkdir("{}/Agregats/imgJpg".format(os.getcwd()))

    def nextImage(self):
        """
        Image suivante si apercu est coché
        """
        global i
        self.pushButton_5.setDown(True)
        cond.acquire()
        cond.notify()
        cond.release()
        if classif and not color and seg:
            time.sleep(0.01)
            self.progressBar.setValue(i)
            time.sleep(0.01)
            self.progressBar_2.setValue(i)
            time.sleep(0.01)
            self.progressBar_4.setValue(i)
            time.sleep(0.01)
        elif classif and not color and not seg:
            time.sleep(0.01)
            self.progressBar.setValue(i)
            time.sleep(0.01)
            self.progressBar_2.setValue(i)
            time.sleep(0.01)
        elif classif and color and seg:
            time.sleep(0.01)
            self.progressBar_3.setValue(i)
            time.sleep(0.01)
            self.progressBar_4.setValue(i)
            time.sleep(0.01)
        elif color and not seg: 
            time.sleep(0.01)
            self.progressBar_3.setValue(i)
            time.sleep(0.01)
        elif not classif and seg:
            time.sleep(0.01)
            self.progressBar_4.setValue(i)
            time.sleep(0.01)

    def readImages(self):
        """
        Lecture des images mixes
        """
        image_dir = os.path.join(os.getcwd(), 'MixedImages')
        return [f for f in os.listdir(image_dir) if os.path.isfile(os.path.join(image_dir, f))], image_dir

    def readImages2(self):
        """
        Lectur des images Agrégats si uniquement segmentation
        """
        image_dir = os.path.join(os.getcwd(), 'Agregats')
        return [f for f in os.listdir(image_dir) if os.path.isfile(os.path.join(image_dir, f))], image_dir


    """ CHECBOX """
    # Gestion des cases cochées et adaptation de l'interface est des booléens
    def classif_actionChange(self):
        global classif
        if self.checkBox_5.isChecked():
            classif= True
            self.checkBox.setChecked(True)
            self.checkBox_4.setChecked(True)
            self.progressBar_3.show()
            self.label_21.show()
            self.label_18.show()
            self.progressBar.show()
            self.progressBar_2.show()
            self.label_20.show()
        else:
            classif = False
            self.checkBox.setChecked(False)
            self.checkBox_4.setChecked(False)
            self.checkBox_2.setChecked(False)
            self.progressBar_3.hide()
            self.label_21.hide()
            self.label_18.hide()
            self.progressBar.hide()
            self.progressBar_2.hide()
            self.label_20.hide()
        
    def seg_actionChange(self):
        global seg
        if self.checkBox_6.isChecked():
            seg = True
            self.progressBar_4.show()
            self.label_22.show()
        else:
            seg = False
            self.progressBar_4.hide()
            self.label_22.hide()

    def blob_actionChange(self):
        global blob, hough
        if self.checkBox.isChecked():
            blob = True
            hough = True
            self.checkBox_5.setChecked(True)
            self.checkBox_4.setChecked(True)
            self.checkBox_2.setChecked(False)
            self.progressBar_3.hide()
            self.label_21.hide()
            self.label_18.show()
            self.progressBar.show()
            self.progressBar_2.show()
            self.label_20.show()
        else:
            blob = False
            hough = False
            self.checkBox.setChecked(False)
            self.checkBox_4.setChecked(False)
            if classif:
                self.checkBox_2.setChecked(True)

    def hough_actionChange(self):
        global blob, hough
        if self.checkBox_4.isChecked():
            blob = True
            hough = True
            self.checkBox_5.setChecked(True)
            self.checkBox.setChecked(True)
            self.checkBox_2.setChecked(False)
            self.progressBar_3.hide()
            self.label_21.hide()
            self.label_18.show()
            self.progressBar.show()
            self.progressBar_2.show()
            self.label_20.show()
        else:
            blob = False
            hough = False
            self.checkBox.setChecked(False)
            self.checkBox_4.setChecked(False)
            if classif:
                self.checkBox_2.setChecked(True)

    def color_actionChange(self):
        global color, blob, hough
        if self.checkBox_2.isChecked():
            color = True
            blob = False
            hough = False
            self.checkBox_5.setChecked(True)
            self.checkBox.setChecked(False)
            self.checkBox_4.setChecked(False)

            self.progressBar_3.show()
            self.label_21.show()

            self.label_18.hide()
            self.progressBar.hide()
            self.progressBar_2.hide()
            self.label_20.hide()
        else :
            color = False
            self.label_18.hide()
            self.progressBar.hide()
            self.progressBar_2.hide()
            self.label_20.hide()
            if classif:
                self.checkBox.setChecked(True)
                self.checkBox_4.setChecked(True)

    def apercu_actionChange(self):
        global apercu
        if self.checkBox_3.isChecked():
            apercu = True
        else: 
            apercu = False

    """FONCTION PROGRAMME"""
    def refresh(self):
        self.progressBar.setValue(0)
        self.progressBar_2.setValue(0)
        self.progressBar_3.setValue(0)
        self.progressBar_4.setValue(0)
        self.progressBar.setStyleSheet(DEFAULT_STYLE)
        self.progressBar_2.setStyleSheet(DEFAULT_STYLE)
        self.progressBar_3.setStyleSheet(DEFAULT_STYLE)
        self.progressBar_4.setStyleSheet(DEFAULT_STYLE)
        img = QImage("Image.png")
        self.label_5.setPixmap(QtGui.QPixmap(img))

    def lancement(self):
        """
        Fonction exécuter lorsque l'on appuye sur start
        """
        self.pushButton_5.setDown(True)
        if (classif and seg )or (classif and not seg):
            self.create_dir()

        if seg and not classif:
                # Segmentation
                action = Action(self.segment_only)
                action.start()
        else:
            # Classification (+ Segmentation)
            if blob:
                #Blob + Hough
                action = Action(self.blob_detector)
                action.start()
            elif color:
                # Couleur
                action = Action(self.color_detector)
                action.start()
        
    def affichage_blobs(self,image_gray, blobs_log):
        """
        Fonction d'affichage des résultats pour les blobs
        """
        fig, axes = plt.subplots(1, 1, figsize=(4.5, 4.5), sharex=True, sharey=True)
        axes.imshow(image_gray)
        for blob in blobs_log:
            y, x, r = blob
            c = plt.Circle((x, y), r, color="yellow", linewidth=2, fill=False)
            axes.add_patch(c)
        axes.set_axis_off()
        if len(blobs_log) > 1:
            plt.title("Agregat")
        else: 
            plt.title("Simple")
        plt.savefig(pathApercu)
        img = QImage(pathApercu)
        self.label_5.setPixmap(QtGui.QPixmap(img))

    def affichage_circles(self, image, img, multi):
        """
        Fonction d'affichage des résultats pour les cercles
        """
        fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(4.5, 4.5))
        ax.imshow(image, cmap=plt.cm.gray)
        if multi:
            plt.title("Agregat")
        else:
            plt.title("Simple")
        ax.set_axis_off()
        plt.savefig(pathApercu)
        img = QImage(pathApercu)
        self.label_5.setPixmap(QtGui.QPixmap(img))

    def extrem_pixels(self,imageBW):
        """
        Récupère les pixels etremes pour avoir une idée de la taille de la particule
        """
        imagePos = dict() 
        k=0
        for i in range(imageBW.shape[0]):
            for j in range(imageBW.shape[1]):
                k+=1
                if  imageBW[i,j] == 255:
                    imagePos[k] = [i,j]
                else :
                    imagePos[k] = [-1,-1]
        top = 255
        bot = 0
        left = 255
        right = 0
        for pixel_pos in imagePos.values():
            if pixel_pos != [-1,-1]:
                if pixel_pos[0] < top :
                    top = pixel_pos[0]
                if pixel_pos[0] > bot :
                    bot= pixel_pos[0]
                if pixel_pos[1] < left :
                    left= pixel_pos[1]
                if pixel_pos[1] > right :
                    right = pixel_pos[1]
        return top, bot, left, right
    
    def isOverlapCenter(self,cx, cy,ecart_max):
        """
        Vérifie si tout les cercles ont le mêmes centre
        """
        Xover = True
        Yover = True
        for e in cx:
            if abs(e-cx.mean()) > ecart_max:
                Xover = False
        for e in cy:
                if abs(e-cy.mean()) > ecart_max:
                    Yover = False        
        return Xover and Yover

    def get_neighbourhood(self, edges, i, j):
        """
        Récupère les voisins du pixel i,j
        """
        if i != 1 and i != edges.shape[0] -1 and j!= 1 and j != edges.shape[0] -1:
            return np.array([edges[i-1,j-1],edges[i-1,j],edges[i-1,j+1],edges[i,j-1],edges[i,j+1],edges[i+1,j-1],edges[i+1,j],edges[i+1,j+1]])
        else :
            return np.array([])

    def keep_edges(self, edges):
        """
        Conservation des contours d'une segmentation
        """
        edges1 = []
        for i in range(edges.shape[0]):
            edges1_int = []
            for j in range(edges.shape[1]):
                if (edges[i,j] == 255 and np.mean(self.get_neighbourhood(edges,i,j)) == 255) or edges[i][j]==0:
                    edges1_int.append(0)
                else:
                    edges1_int.append(255)
            edges1.append(edges1_int)
        return np.array(edges1)
        
    """CLASSIFICATION + SEGMENTATION"""
    def blob_detectorThread(self, i, images, image_dir):
        """
        Thread - Détecteur de  blob
        """
        global pathApercu, blob_on , hough_on, color_on, seg_on, seg_only_on
        blob_on = True
        hough_on = False
        color_on = False
        seg_on = False
        seg_only_on = False

        ratioX_norm = self.doubleSpinBox.value()
        ratioY_norm = self.doubleSpinBox_2.value()
        min_sigma_petit = self.doubleSpinBox_3.value()
        max_sigma_petit = self.doubleSpinBox_4.value()
        overlap_petit = self.doubleSpinBox_8.value()
        threshold_petit = self.doubleSpinBox_9.value()
        
        min_sigma_grand = self.doubleSpinBox_5.value()
        max_sigma_grand = self.doubleSpinBox_6.value()
        overlap_grand = self.doubleSpinBox_10.value()
        threshold_grand = self.doubleSpinBox_13.value()
        
        image = images[i]
        name = image
        full_image_path = os.path.join(image_dir, image)
        image = np.array(Image.open(("{}/{}").format(image_dir, name)))
        image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

        imgPath = "imgJpg/"+name.split(".")[0]+".jpg"
        pathApercu = os.path.join(image_dir, imgPath)
        imageBW = np.where(image_gray > 50,255,0)
        top, bot, left, right = self.extrem_pixels(imageBW)
        ratioX, ratioY =abs(bot-top) / imageBW.shape[1], abs(right-left) / imageBW.shape[0]

        if ratioX >= ratioX_norm or ratioY >= ratioY_norm:
            blobs_log = blob_dog(image_gray, min_sigma=min_sigma_grand,max_sigma=max_sigma_grand, overlap=overlap_grand, threshold=threshold_grand)
        else:
            blobs_log = blob_dog(image_gray, min_sigma=min_sigma_petit,max_sigma=max_sigma_petit, overlap=overlap_petit, threshold=threshold_petit)

        if apercu:
            self.affichage_blobs(image_gray, blobs_log)
            time.sleep(0.5)

        hough_ok = self.hough_detectorThread(i, images, image_dir)
        
        if dontmove == False:
            if (len(blobs_log) > 1 and hough_ok) :
                if seg:
                    self.watershed_global(image, name)
                shutil.copy(full_image_path, "{}/Agregats".format(os.getcwd()))
            else:
                shutil.copy(full_image_path, "{}/Simples".format(os.getcwd()))
        if apercu:
            self.pushButton_5.setDown(False)
    
    def blob_detector(self):
        """
        Détecteur de blob
        """
        global i, images, image_dir
        images, image_dir = self.readImages()
        self.progressBar.setMaximum(len(images))
        self.progressBar_2.setMaximum(len(images))
        self.progressBar_4.setMaximum(len(images))
        i=0
        while i < len(images):
            if apercu:
                cond.acquire()
                blob_action = threading.Thread(target=self.blob_detectorThread, args=(i,images, image_dir,))
                blob_action.start()
                cond.wait()
                cond.release()
            else:
                self.blob_detectorThread( i, images, image_dir)
                self.progressBar.setValue(i)
                self.progressBar_2.setValue(i)
                self.progressBar_4.setValue(i)
            i+=1
        self.progressBar.setValue(len(images))
        self.progressBar.setStyleSheet(COMPLETED_STYLE)
        time.sleep(0.005)
        self.progressBar_2.setValue(len(images))
        self.progressBar_2.setStyleSheet(COMPLETED_STYLE)
        time.sleep(0.005)
        self.progressBar_4.setValue(len(images))
        self.progressBar_4.setStyleSheet(COMPLETED_STYLE)
        time.sleep(0.005)

    def hough_detectorThread(self, i, images, image_dir):
        """
        Thread - Détecteur de cercle
        """
        global pathApercu, blob_on , hough_on, color_on, seg_on, seg_only_on
        blob_on = False
        hough_on = True
        color_on = False
        seg_on = False
        seg_only_on = False

        nb_circles = self.spinBox.value()
        ecart_max = self.spinBox_2.value()
        min_radius_grand = self.doubleSpinBox_7.value()
        max_radius_grand = self.doubleSpinBox_14.value()

        image = images[i]
        name = image
        full_image_path = os.path.join(image_dir, image)
        image = cv2.imread(full_image_path)
        image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
       
        imgPath = "imgJpg/"+name.split(".")[0]+".jpg"
        pathApercu = os.path.join(image_dir, imgPath)
        img = image.copy()
        gray = image_gray
        ret, thresh = cv2.threshold(gray,0,255,cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)
        kernel = np.ones((3,3),np.uint8)
        opening = cv2.morphologyEx(thresh,cv2.MORPH_OPEN,kernel, iterations = 2)
        sure_bg = cv2.dilate(opening,kernel,iterations=3)
        dist_transform = cv2.distanceTransform(opening,cv2.DIST_L2,5)
        ret, sure_fg = cv2.threshold(dist_transform,0.7*dist_transform.max(),255,0)
        sure_fg = np.uint8(sure_fg)
        unknown = cv2.subtract(sure_bg,sure_fg)
        ret, markers = cv2.connectedComponents(sure_fg)
        markers = markers+1
        markers[unknown==255] = 0
        markers = cv2.watershed(img,markers)
        edges = np.where(markers == 1,255,0)

        hough_radii = np.arange(min_radius_grand, max_radius_grand, 3)
        hough_res = hough_circle(edges, hough_radii)
        accums, cx, cy, radii = hough_circle_peaks(hough_res, hough_radii, total_num_peaks=nb_circles) # selection les max locaux

        multi = not self.isOverlapCenter(cx,cy,ecart_max)

        if apercu:
            listeCenter = list()
            for center_y, center_x, radius in zip(cy, cx, radii):
                radius = int(radius)
                circy, circx = circle_perimeter(center_y, center_x, radius,
                                                shape=image.shape)
                image[circy, circx] = (220, 20, 20)
                listeCenter.append([center_x, center_y])
            self.affichage_circles(image, img, multi)
            time.sleep(0.5)
        
        if multi : 
            return True
        return False

    def color_detectorThread(self, i, images, image_dir):
        """
        Thread - Couleur
        """
        global blob_on , hough_on, color_on, seg_on, seg_only_on
        blob_on = False
        hough_on = False
        color_on = True
        seg_on = False
        seg_only_on = False

        image = images[i]
        name = image
        full_image_path = os.path.join(image_dir, image)
        image = cv2.imread(full_image_path)
        image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        s = self.spinBox_3.value()
        image_bin = np.where(image_gray > s, 255,0)
        multi = False
        
        if image_bin[0][0] == 255:
            multi = True
            if apercu:
                fig, ax = plt.subplots()
                ax.imshow(image, cmap=plt.cm.nipy_spectral)
                if multi:
                    ax.set_title('Agregat')
                else:
                    ax.set_title('Simple')
                imgPath = "imgJpg/"+name.split(".")[0]+".jpg"
                pathApercu = os.path.join(image_dir, imgPath)
                plt.savefig(pathApercu)
                img = QImage(pathApercu)
                self.label_5.setPixmap(QtGui.QPixmap(img))
                time.sleep(0.5)
            if seg:
                self.watershed_global(image, name)
            if dontmove == False:
                shutil.copy(full_image_path, "{}/Agregats".format(os.getcwd()))
        else:
            if apercu:
                fig, ax = plt.subplots()
                ax.imshow(image, cmap=plt.cm.nipy_spectral)
                if multi:
                    ax.set_title('Agregat')
                else:
                    ax.set_title('Simple')
                imgPath = "imgJpg/"+name.split(".")[0]+".jpg"
                pathApercu = os.path.join(image_dir, imgPath)
                plt.savefig(pathApercu)
                img = QImage(pathApercu)
                self.label_5.setPixmap(QtGui.QPixmap(img))
                time.sleep(0.5)
            if dontmove == False:
                shutil.copy(full_image_path, "{}/Simples".format(os.getcwd()))
        if apercu:
            self.pushButton_5.setDown(False)

    def color_detector(self):
        """
        Détecteur couleur
        """
        global i, images, image_dir
        images, image_dir = self.readImages()
        self.progressBar_3.setMaximum(len(images))
        self.progressBar_4.setMaximum(len(images))
        i=0
        while i < len(images):
            if apercu:
                cond.acquire()
                color_action = threading.Thread(target=self.color_detectorThread, args=(i, images, image_dir))
                color_action.start()
                cond.wait()
                cond.release()
            else:
                self.color_detectorThread(i, images, image_dir)
                self.progressBar_3.setValue(i)
                self.progressBar_4.setValue(i)
            i+=1
        time.sleep(0.005)
        self.progressBar_3.setValue(len(images))
        self.progressBar_3.setStyleSheet(COMPLETED_STYLE)
        time.sleep(0.005)
        self.progressBar_4.setValue(len(images))
        self.progressBar_4.setStyleSheet(COMPLETED_STYLE)
        time.sleep(0.005)

    def watershed_global(self, img, name):
        """
        Segmentation des agrégats
        """
        nb_circles = self.spinBox_5.value()
        min_r = self.spinBox_4.value()
        max_r = self.spinBox_6.value()

        imgPath = "imgJpg/"+name.split(".")[0]+".jpg"
        pathApercu = os.path.join(image_dir, imgPath)

        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        ret, thresh = cv2.threshold(gray,0,255,cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)
        kernel = np.ones((3,3),np.uint8)
        opening = cv2.morphologyEx(thresh,cv2.MORPH_OPEN,kernel, iterations = 2)
        sure_bg = cv2.dilate(opening,kernel,iterations=3)
        dist_transform = cv2.distanceTransform(opening,cv2.DIST_L2,5)
        ret, sure_fg = cv2.threshold(dist_transform,0.7*dist_transform.max(),255,0)
        sure_fg = np.uint8(sure_fg)
        unknown = cv2.subtract(sure_bg,sure_fg)
        ret, markers = cv2.connectedComponents(sure_fg)
        markers = markers+1
        markers[unknown==255] = 0
        markers = cv2.watershed(img,markers)
        edges = np.where(markers == 1,255,0)


        hough_radii = np.arange(min_r, max_r, 2)
        hough_res = hough_circle(edges, hough_radii)
        accums, cx, cy, radii = hough_circle_peaks(hough_res, hough_radii, total_num_peaks=nb_circles)

        # SI LES 2 CENTRES LES PLUS LOIN SONT TROP PROCHE => SIMPLE  
        # diag1
        Point0 = [0,0]
        Point1 = [edges.shape[0],edges.shape[0]]
        minPoint0 = [100000, 100000]
        maxPoint0 = [100000, 100000]
        for center_y, center_x, radius in zip(cy, cx, radii):
            point = [center_y, center_x]
            if distance.euclidean(Point0, point) < distance.euclidean(Point0, minPoint0):
                minPoint0 = point
            if distance.euclidean(Point1, point) < distance.euclidean(Point1, maxPoint0):
                maxPoint0 = point    
        d0 = distance.euclidean(minPoint0, maxPoint0)

        # diag2
        Point0 = [0,edges.shape[0]]
        Point1 = [edges.shape[0],0]
        minPoint3 = [100000, 100000]
        maxPoint3 = [100000, 100000]
        for center_y, center_x, radius in zip(cy, cx, radii):
            point = [center_y, center_x]
            if distance.euclidean(Point0, point) < distance.euclidean(Point0, minPoint3):
                minPoint3 = point
            if distance.euclidean(Point1, point) < distance.euclidean(Point1, maxPoint3):
                maxPoint3 = point    
        d3 = distance.euclidean(minPoint3, maxPoint3)

        # vert
        Point0 = [0,edges.shape[0]//2]
        Point1 = [edges.shape[0],edges.shape[0]//2]
        minPoint1 = [100000, 100000]
        maxPoint1 = [100000, 100000]

        for center_y, center_x, radius in zip(cy, cx, radii):
            point = [center_y, center_x]
            if distance.euclidean(Point0, point) < distance.euclidean(Point0, minPoint1):
                minPoint1 = point
            if distance.euclidean(Point1, point) < distance.euclidean(Point1, maxPoint1):
                maxPoint1 = point
        d1 = distance.euclidean(minPoint1, maxPoint1)

        # horiz
        Point0 = [edges.shape[0]//2, 0]
        Point1 = [edges.shape[0]//2,edges.shape[0]]
        minPoint2 = [100000, 100000]
        maxPoint2 = [100000, 100000]
        for center_y, center_x, radius in zip(cy, cx, radii):
            point = [center_y, center_x]
            if distance.euclidean(Point0, point) < distance.euclidean(Point0, minPoint2):
                minPoint2 = point
            if distance.euclidean(Point1, point) < distance.euclidean(Point1, maxPoint2):
                maxPoint2 = point

        d2 = distance.euclidean(minPoint2, maxPoint2)

        list_dist = np.array([d0, d1, d2, d3])
        argmax = np.argmax(list_dist)
        if argmax == 0:
            maxPoint = maxPoint0 
            minPoint = minPoint0
        elif argmax == 1:
            maxPoint = maxPoint1 
            minPoint = minPoint1
        elif argmax == 2:
            maxPoint = maxPoint2 
            minPoint = minPoint2
        else:
            maxPoint = maxPoint3 
            minPoint = minPoint3
            
        lst_coords=[]
        lst_coords.append(minPoint)
        lst_coords.append(maxPoint)
        thresh = 0.3
        multi = False
        if distance.euclidean(minPoint, maxPoint) > thresh*70 or color:
            multi = True
            for cx_,cy_ in zip(cx,cy):
                add = True
                for coord in lst_coords:
                    if distance.euclidean(coord, [cy_,cx_]) < np.max(radii):
                        add = False
                if add:
                    lst_coords.append([cy_,cx_])
            lst_coords = np.array(lst_coords)
            
            image = edges
            mask = np.zeros(image.shape, dtype=bool)
            mask[tuple(lst_coords.T)] = True
            markers, _ = ndi.label(mask)
            labels = watershed(image, markers, mask=image)
            
            unique_label = np.unique(labels)
            k=0
            for label in unique_label:
                if label != 0:
                    mask = np.where(labels == label, 1,0)
                    mask_color = np.zeros((mask.shape[0],mask.shape[1],3))
                    for i in range(mask.shape[0]):
                        for j in range(mask.shape[1]):
                            if mask[i,j] == 0:
                                mask_color[i,j][0] = 0
                                mask_color[i,j][1] = 0
                                mask_color[i,j][2] = 0
                            else:
                                mask_color[i,j][0] = 1
                                mask_color[i,j][1] = 1
                                mask_color[i,j][2] = 1

                    fig, ax = plt.subplots()
                    ax.imshow((img*mask_color).astype(int))
                    plt.axis('off')
                    fig.savefig("Agregats/Segmented/{}_{}.tif".format(name.split(".")[0], k), bbox_inches='tight', pad_inches=0)
                    k+=1

            if apercu:
                if seg and not classif:
                    imgPath = "imgJpg/"+name.split(".")[0]+".jpg"
                    pathApercu = os.path.join(image_dir, imgPath)
                    plt.savefig(pathApercu)

                fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(4.5, 4.5))
                ax.imshow(labels, cmap=plt.cm.gray)
                if multi:
                    plt.title("Agregat")
                else:
                    plt.title("Simple")
                ax.set_axis_off()
                plt.savefig(pathApercu)
                img = QImage(pathApercu)
                self.label_5.setPixmap(QtGui.QPixmap(img))
        
        if apercu and seg and not classif:
            self.pushButton_5.setDown(False)
    
    def segment_only(self):
        """
        Si que segmentation
        """
        global i, images, image_dir, blob_on , hough_on, color_on, seg_on, seg_only_on
        blob_on = False
        hough_on = False
        color_on = False
        seg_on = False
        seg_only_on = True

        if apercu and dontmove == False:
            if os.path.isdir(("{}/Agregats/imgJpg".format(os.getcwd()))):
                shutil.rmtree("{}/Agregats/imgJpg".format(os.getcwd()))
            os.mkdir("{}/Agregats/imgJpg".format(os.getcwd()))

        images, image_dir = self.readImages2()
        self.progressBar_4.setMaximum(len(images))
        i=0
        while i < len(images):
            image = images[i]
            name = image
            full_image_path = os.path.join(image_dir, image)
            image = cv2.imread(full_image_path)
            if apercu and len(images) > 1:
                    cond.acquire()
                    color_action = threading.Thread(target=self.watershed_global, args=(image, name))
                    color_action.start()
                    self.progressBar_4.setValue(i)
                    cond.wait()
                    cond.release()
            else:
                self.watershed_global(image, name)
                self.progressBar_4.setValue(i)
            i+=1
        self.progressBar_4.setValue(len(images))
        self.progressBar_4.setStyleSheet(COMPLETED_STYLE)


    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1351, 707)
        MainWindow.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        MainWindow.setMouseTracking(False)
        MainWindow.setAutoFillBackground(False)
        MainWindow.setStyleSheet("background-color: rgb(115,115, 115);")
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.widget_3 = QtWidgets.QWidget(self.centralwidget)
        self.widget_3.setGeometry(QtCore.QRect(30, 40, 581, 421))
        self.widget_3.setStyleSheet("background-color: rgb(0,0,0)")
        self.widget_3.setObjectName("widget_3")
        self.label_5 = QtWidgets.QLabel(self.widget_3)
        self.label_5.setGeometry(QtCore.QRect(10, 10, 561, 401))
        self.label_5.setStyleSheet("background-color: rgb(255,255,255)")
        self.label_5.setText("")
        self.label_5.setObjectName("label_5")
        self.label_6 = QtWidgets.QLabel(self.centralwidget)
        self.label_6.setGeometry(QtCore.QRect(980, 650, 111, 111))
        self.label_6.setText("")
        self.label_6.setPixmap(QtGui.QPixmap("220px-Colors-i54-ring.png"))
        self.label_6.setObjectName("label_6")
        self.progressBar = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar.setGeometry(QtCore.QRect(210, 480, 321, 23))
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")
        self.checkBox_3 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_3.setGeometry(QtCore.QRect(650, 100, 82, 23))
        self.checkBox_3.setObjectName("checkBox_3")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(650, 60, 80, 25))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_1 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_1.setGeometry(QtCore.QRect(736, 60, 80, 25))
        self.pushButton_1.setObjectName("pushButton_1")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(630, 280, 111, 17))
        self.label_2.setObjectName("label_2")
        self.label_18 = QtWidgets.QLabel(self.centralwidget)
        self.label_18.setGeometry(QtCore.QRect(70, 480, 111, 17))
        self.label_18.setObjectName("label_18")
        self.label_20 = QtWidgets.QLabel(self.centralwidget)
        self.label_20.setGeometry(QtCore.QRect(70, 520, 111, 17))
        self.label_20.setObjectName("label_20")
        self.label_21 = QtWidgets.QLabel(self.centralwidget)
        self.label_21.setGeometry(QtCore.QRect(70, 560, 41, 17))
        self.label_21.setObjectName("label_21")
        self.checkBox_2 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_2.setGeometry(QtCore.QRect(1130, 170, 131, 23))
        self.checkBox_2.setObjectName("checkBox_2")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(1120, 60, 111, 17))
        self.label.setStyleSheet("")
        self.label.setLineWidth(1)
        self.label.setObjectName("label")
        self.checkBox_4 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_4.setGeometry(QtCore.QRect(1130, 130, 131, 23))
        self.checkBox_4.setChecked(True)
        self.checkBox_4.setObjectName("checkBox_4")
        self.checkBox = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox.setGeometry(QtCore.QRect(1130, 100, 131, 23))
        self.checkBox.setChecked(True)
        self.checkBox.setObjectName("checkBox")
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWidget.setGeometry(QtCore.QRect(620, 320, 651, 341))
        self.tabWidget.setStyleSheet("background-color: rgb(150,150, 150);")
        self.tabWidget.setObjectName("tabWidget")
        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.doubleSpinBox = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox.setGeometry(QtCore.QRect(60, 30, 121, 26))
        self.doubleSpinBox.setSingleStep(0.1)
        self.doubleSpinBox.setProperty("value", 0.6)
        self.doubleSpinBox.setObjectName("doubleSpinBox")
        self.doubleSpinBox_2 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_2.setGeometry(QtCore.QRect(270, 30, 121, 26))
        self.doubleSpinBox_2.setSingleStep(0.1)
        self.doubleSpinBox_2.setProperty("value", 0.6)
        self.doubleSpinBox_2.setObjectName("doubleSpinBox_2")
        self.doubleSpinBox_3 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_3.setGeometry(QtCore.QRect(90, 120, 131, 26))
        self.doubleSpinBox_3.setSingleStep(0.5)
        self.doubleSpinBox_3.setProperty("value", 30)
        self.doubleSpinBox_3.setObjectName("doubleSpinBox_3")
        self.doubleSpinBox_4 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_4.setGeometry(QtCore.QRect(90, 150, 131, 26))
        self.doubleSpinBox_4.setSingleStep(0.5)
        self.doubleSpinBox_4.setProperty("value", 70)
        self.doubleSpinBox_4.setObjectName("doubleSpinBox_4")
        self.doubleSpinBox_8 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_8.setGeometry(QtCore.QRect(90, 190, 131, 26))
        self.doubleSpinBox_8.setSingleStep(0.1)
        self.doubleSpinBox_8.setProperty("value", 0.7)
        self.doubleSpinBox_8.setObjectName("doubleSpinBox_8")
        self.doubleSpinBox_9 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_9.setGeometry(QtCore.QRect(90, 230, 131, 26))
        self.doubleSpinBox_9.setSingleStep(0.01)
        self.doubleSpinBox_9.setProperty("value", 0.2)
        self.doubleSpinBox_9.setObjectName("doubleSpinBox_9")
        self.label_3 = QtWidgets.QLabel(self.tab_3)
        self.label_3.setGeometry(QtCore.QRect(10, 30, 41, 17))
        self.label_3.setObjectName("label_3")
        self.label_4 = QtWidgets.QLabel(self.tab_3)
        self.label_4.setGeometry(QtCore.QRect(220, 30, 41, 17))
        self.label_4.setObjectName("label_4")
        self.label_8 = QtWidgets.QLabel(self.tab_3)
        self.label_8.setGeometry(QtCore.QRect(90, 80, 121, 17))
        self.label_8.setObjectName("label_8")
        self.label_10 = QtWidgets.QLabel(self.tab_3)
        self.label_10.setGeometry(QtCore.QRect(10, 120, 71, 17))
        self.label_10.setObjectName("label_10")
        self.label_11 = QtWidgets.QLabel(self.tab_3)
        self.label_11.setGeometry(QtCore.QRect(10, 160, 71, 17))
        self.label_11.setObjectName("label_11")
        self.label_12 = QtWidgets.QLabel(self.tab_3)
        self.label_12.setGeometry(QtCore.QRect(10, 190, 51, 17))
        self.label_12.setObjectName("label_12")
        self.label_13 = QtWidgets.QLabel(self.tab_3)
        self.label_13.setGeometry(QtCore.QRect(10, 230, 61, 17))
        self.label_13.setObjectName("label_13")
        self.label_17 = QtWidgets.QLabel(self.tab_3)
        self.label_17.setGeometry(QtCore.QRect(340, 220, 71, 17))
        self.label_17.setObjectName("label_17")
        self.label_14 = QtWidgets.QLabel(self.tab_3)
        self.label_14.setGeometry(QtCore.QRect(340, 180, 51, 17))
        self.label_14.setObjectName("label_14")
        self.label_9 = QtWidgets.QLabel(self.tab_3)
        self.label_9.setGeometry(QtCore.QRect(410, 80, 125, 17))
        self.label_9.setObjectName("label_9")
        self.doubleSpinBox_10 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_10.setGeometry(QtCore.QRect(420, 170, 131, 26))
        self.doubleSpinBox_10.setSingleStep(0.1)
        self.doubleSpinBox_10.setProperty("value", 0.7)
        self.doubleSpinBox_10.setObjectName("doubleSpinBox_10")
        self.doubleSpinBox_13 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_13.setGeometry(QtCore.QRect(420, 210, 131, 26))
        self.doubleSpinBox_13.setSingleStep(0.01)
        self.doubleSpinBox_13.setProperty("value", 0.2)
        self.doubleSpinBox_13.setObjectName("doubleSpinBox_13")
        self.doubleSpinBox_5 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_5.setGeometry(QtCore.QRect(420, 110, 131, 26))
        self.doubleSpinBox_5.setSingleStep(0.5)
        self.doubleSpinBox_5.setProperty("value", 20)
        self.doubleSpinBox_5.setObjectName("doubleSpinBox_5")
        self.label_16 = QtWidgets.QLabel(self.tab_3)
        self.label_16.setGeometry(QtCore.QRect(340, 120, 71, 17))
        self.label_16.setObjectName("label_16")
        self.label_15 = QtWidgets.QLabel(self.tab_3)
        self.label_15.setGeometry(QtCore.QRect(340, 150, 71, 17))
        self.label_15.setObjectName("label_15")
        self.doubleSpinBox_6 = QtWidgets.QDoubleSpinBox(self.tab_3)
        self.doubleSpinBox_6.setGeometry(QtCore.QRect(420, 140, 131, 26))
        self.doubleSpinBox_6.setSingleStep(0.5)
        self.doubleSpinBox_6.setProperty("value", 30)
        self.doubleSpinBox_6.setObjectName("doubleSpinBox_6")
        self.tabWidget.addTab(self.tab_3, "")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.doubleSpinBox_7 = QtWidgets.QDoubleSpinBox(self.tab)
        self.doubleSpinBox_7.setGeometry(QtCore.QRect(140, 230, 131, 26))
        self.doubleSpinBox_7.setSingleStep(0.5)
        self.doubleSpinBox_7.setProperty("value", 20.0)
        self.doubleSpinBox_7.setObjectName("doubleSpinBox_7")
        self.label_7 = QtWidgets.QLabel(self.tab)
        self.label_7.setGeometry(QtCore.QRect(10, 80, 111, 17))
        self.label_7.setObjectName("label_7")
        self.spinBox = QtWidgets.QSpinBox(self.tab)
        self.spinBox.setGeometry(QtCore.QRect(140, 80, 121, 26))
        self.spinBox.setProperty("value", 7)
        self.spinBox.setObjectName("spinBox")
        self.label_24 = QtWidgets.QLabel(self.tab)
        self.label_24.setGeometry(QtCore.QRect(30, 230, 81, 17))
        self.label_24.setObjectName("label_24")
        self.label_26 = QtWidgets.QLabel(self.tab)
        self.label_26.setGeometry(QtCore.QRect(10, 130, 91, 17))
        self.label_26.setObjectName("label_26")
        self.spinBox_2 = QtWidgets.QSpinBox(self.tab)
        self.spinBox_2.setGeometry(QtCore.QRect(140, 120, 121, 26))
        self.spinBox_2.setProperty("value", 2)
        self.spinBox_2.setObjectName("spinBox_2")
        self.label_25 = QtWidgets.QLabel(self.tab)
        self.label_25.setGeometry(QtCore.QRect(30, 280, 81, 17))
        self.label_25.setObjectName("label_25")
        self.doubleSpinBox_14 = QtWidgets.QDoubleSpinBox(self.tab)
        self.doubleSpinBox_14.setGeometry(QtCore.QRect(140, 270, 131, 26))
        self.doubleSpinBox_14.setSingleStep(0.5)
        self.doubleSpinBox_14.setProperty("value", 70.0)
        self.doubleSpinBox_14.setObjectName("doubleSpinBox_14")
        self.label_28 = QtWidgets.QLabel(self.tab)
        self.label_28.setGeometry(QtCore.QRect(80, 200, 81, 17))
        self.label_28.setObjectName("label_28")


        self.tabWidget.addTab(self.tab, "")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.spinBox_3 = QtWidgets.QSpinBox(self.tab_2)
        self.spinBox_3.setGeometry(QtCore.QRect(80, 50, 111, 26))
        self.spinBox_3.setMaximum(255)
        self.spinBox_3.setProperty("value", 30)
        self.spinBox_3.setObjectName("spinBox_3")
        self.label_32 = QtWidgets.QLabel(self.tab_2)
        self.label_32.setGeometry(QtCore.QRect(20, 50, 41, 17))
        self.label_32.setObjectName("label_32")
        self.tabWidget.addTab(self.tab_2, "")
        self.tab_4 = QtWidgets.QWidget()
        self.tab_4.setObjectName("tab_4")
        self.label_33 = QtWidgets.QLabel(self.tab_4)
        self.label_33.setGeometry(QtCore.QRect(20, 50, 81, 17))
        self.label_33.setObjectName("label_33")
        self.label_34 = QtWidgets.QLabel(self.tab_4)
        self.label_34.setGeometry(QtCore.QRect(20, 110, 81, 17))
        self.label_34.setObjectName("label_34")
        self.spinBox_4 = QtWidgets.QSpinBox(self.tab_4)
        self.spinBox_4.setGeometry(QtCore.QRect(120, 50, 121, 26))
        self.spinBox_4.setProperty("value", 20)
        self.spinBox_4.setObjectName("spinBox_4")
        self.spinBox_5 = QtWidgets.QSpinBox(self.tab_4)
        self.spinBox_5.setGeometry(QtCore.QRect(120, 100, 121, 26))
        self.spinBox_5.setProperty("value", 7)
        self.spinBox_5.setObjectName("spinBox_5")
        self.spinBox_6 = QtWidgets.QSpinBox(self.tab_4)
        self.spinBox_6.setGeometry(QtCore.QRect(370, 50, 121, 26))
        self.spinBox_6.setProperty("value", 70)
        self.spinBox_6.setObjectName("spinBox_6")
        self.label_35 = QtWidgets.QLabel(self.tab_4)
        self.label_35.setGeometry(QtCore.QRect(270, 50, 91, 17))
        self.label_35.setObjectName("label_35")
        self.tabWidget.addTab(self.tab_4, "")
        self.progressBar_2 = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar_2.setGeometry(QtCore.QRect(210, 520, 321, 23))
        self.progressBar_2.setProperty("value", 0)
        self.progressBar_2.setObjectName("progressBar_2")
        self.progressBar_3 = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar_3.setGeometry(QtCore.QRect(210, 560, 321, 23))
        self.progressBar_3.setProperty("value", 0)
        self.progressBar_3.setObjectName("progressBar_3")
        self.label_22 = QtWidgets.QLabel(self.centralwidget)
        self.label_22.setGeometry(QtCore.QRect(70, 610, 111, 17))
        self.label_22.setObjectName("label_22")
        self.progressBar_4 = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar_4.setGeometry(QtCore.QRect(210, 610, 321, 23))
        self.progressBar_4.setProperty("value", 0)
        self.progressBar_4.setObjectName("progressBar_4")
        self.checkBox_5 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_5.setGeometry(QtCore.QRect(940, 120, 131, 23))
        self.checkBox_5.setChecked(True)
        self.checkBox_5.setObjectName("checkBox_5")
        self.checkBox_6 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_6.setGeometry(QtCore.QRect(940, 160, 131, 23))
        self.checkBox_6.setChecked(True)
        self.checkBox_6.setObjectName("checkBox_6")
        self.pushButton_5 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_5.setGeometry(QtCore.QRect(650, 150, 80, 25))
        self.pushButton_5.setObjectName("pushButton_5")
        self.label_19 = QtWidgets.QLabel(self.centralwidget)
        self.label_19.setGeometry(QtCore.QRect(630, 220, 51, 17))
        self.label_19.setStyleSheet("")
        self.label_19.setLineWidth(1)
        self.label_19.setObjectName("label_19")
        self.label_23 = QtWidgets.QLabel(self.centralwidget)
        self.label_23.setGeometry(QtCore.QRect(950, 60, 131, 17))
        self.label_23.setStyleSheet("")
        self.label_23.setLineWidth(1)
        self.label_23.setObjectName("label_23")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1351, 31))
        self.menubar.setTabletTracking(False)
        self.menubar.setStyleSheet("background-color:rgb(255,255,255)")
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setStyleSheet("")
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionQuitter = QtWidgets.QAction(MainWindow)
        self.actionQuitter.setObjectName("actionQuitter")
        self.menuFile.addAction(self.actionQuitter)
        self.menubar.addAction(self.menuFile.menuAction())
        self.progressBar.setStyleSheet(DEFAULT_STYLE)
        self.progressBar_2.setStyleSheet(DEFAULT_STYLE)
        self.progressBar_3.setStyleSheet(DEFAULT_STYLE)
        self.progressBar_4.setStyleSheet(DEFAULT_STYLE)

        self.pushButton.clicked.connect(self.lancement)
        self.pushButton_1.clicked.connect(self.refresh)
        self.actionQuitter.triggered.connect(self.quitter)
        self.checkBox.stateChanged.connect(self.blob_actionChange)
        self.checkBox_2.stateChanged.connect(self.color_actionChange)
        self.checkBox_3.stateChanged.connect(self.apercu_actionChange)
        self.checkBox_4.stateChanged.connect(self.hough_actionChange)
        self.checkBox_5.stateChanged.connect(self.classif_actionChange)
        self.checkBox_6.stateChanged.connect(self.seg_actionChange)
        self.pushButton_5.clicked.connect(self.nextImage)

        self.progressBar_3.hide()
        self.label_21.hide()
        img = QImage("Image.png")
        self.label_5.setPixmap(QtGui.QPixmap(img))
            
        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MicroParticule Multi Detector"))
        self.checkBox_3.setText(_translate("MainWindow", "Apercu"))
        self.pushButton.setText(_translate("MainWindow", "Start"))
        self.pushButton_1.setText(_translate("MainWindow", "Refresh"))
        self.label_2.setText(_translate("MainWindow", "Paramètres"))
        self.label_18.setText(_translate("MainWindow", "Blob Detector"))
        self.label_20.setText(_translate("MainWindow", "Hough"))
        self.label_21.setText(_translate("MainWindow", "Color"))
        self.checkBox_2.setText(_translate("MainWindow", "Color"))
        self.label.setText(_translate("MainWindow", "Classifier mode"))
        self.checkBox_4.setText(_translate("MainWindow", "Hough"))
        self.checkBox.setText(_translate("MainWindow", "Blob"))
        self.label_3.setText(_translate("MainWindow", "ratioX :"))
        self.label_4.setText(_translate("MainWindow", "ratioY :"))
        self.label_8.setText(_translate("MainWindow", "Blob - Petite Particule"))
        self.label_10.setText(_translate("MainWindow", "min_sigma :"))
        self.label_11.setText(_translate("MainWindow", "max_sigma :"))
        self.label_12.setText(_translate("MainWindow", "overlap :"))
        self.label_13.setText(_translate("MainWindow", "threshold :"))
        self.label_17.setText(_translate("MainWindow", "threshold :"))
        self.label_14.setText(_translate("MainWindow", "overlap :"))
        self.label_9.setText(_translate("MainWindow", "Blob - Grand Particule"))
        self.label_16.setText(_translate("MainWindow", "min_sigma :"))
        self.label_15.setText(_translate("MainWindow", "max_sigma :"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("MainWindow", "Blob"))
        self.label_7.setText(_translate("MainWindow", "Nombre de cercles :"))
        self.label_24.setText(_translate("MainWindow", "min radius :"))
        self.label_26.setText(_translate("MainWindow", "Ecart maximal :"))
        self.label_25.setText(_translate("MainWindow", "max radius :"))
        self.label_28.setText(_translate("MainWindow", "Cercle :"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Hough"))
        self.label_32.setText(_translate("MainWindow", "Seuil :"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("MainWindow", "Color"))
        self.label_33.setText(_translate("MainWindow", "min radius :"))
        self.label_34.setText(_translate("MainWindow", "nb cercle :"))
        self.label_35.setText(_translate("MainWindow", "max radius :"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_4), _translate("MainWindow", "Watershed"))
        self.label_22.setText(_translate("MainWindow", "Watershed"))
        self.checkBox_5.setText(_translate("MainWindow", "Classification"))
        self.checkBox_6.setText(_translate("MainWindow", "Segmentation"))
        self.pushButton_5.setText(_translate("MainWindow", "Next"))
        self.label_19.setText(_translate("MainWindow", "Move to"))
        self.label_23.setText(_translate("MainWindow", "Classifer & Segmenter"))
        self.menuFile.setTitle(_translate("MainWindow", "Fichier"))
        self.actionQuitter.setText(_translate("MainWindow", "Quitter"))


if __name__ == "__main__":
    import sys
    
    classif = True
    seg = True
    blob = True
    hough = True
    color = False
    blob_on = False
    hough_on = False
    color_on = False
    seg_on = False
    seg_only_on = False
    apercu = False
    dontmove = False

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
